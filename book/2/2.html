

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="rtl" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


    
         <title>فاصله در درخت و گراف &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-rtl.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="درخت ها" href="index.html" />
        <link rel="next" title="شمردن تعداد درخت ها" href="4.html" />
        <link rel="prev" title="خاصیت های مقدماتی" href="1.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-left " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="جستجو">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">تعاریف اولیه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">مقدمات و مدل سازی با گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">انواع گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">پیاده سازی گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">گشت، گذر، مسیر، اکسترمال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">زیرگراف ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">همبندی، یال برشی و راس برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">گراف دو بخشی</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">درخت ها</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">خاصیت های مقدماتی</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">فاصله در درخت و گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">شمردن تعداد درخت ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">dfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">bfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">الگوریتم پیدا کردن قطر درخت</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.html">الگوریتم های راس و یال برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="9.html">کارگاه پرورش ایده</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">گراف جهت‌دار</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">تعاریف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">تورنومنت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">گراف جهت‌دار بدون دور</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html">مولفه‌های قویا همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">تشخیص دور داشتن گراف جهت دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">بازی‌ها و گراف جهت‌دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">گراف تابعی و گراف جایگشت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">تکنیک های اثبات مسائل گراف</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">انتخاب های اکسترمالی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">منقبض کردن</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">گراف و جادو</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">تور اویلری و دور همیلتونی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">معرفی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">تور اویلری در گراف جهت دار و بی جهت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">قضیه های وجودی دور همیلتونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">الگوریتم های نمایی پیدا کردن دور و مسیر همیلتونی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">الگوریتم های کوتاه ترین مسیر</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">بلمن فورد</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">دکسترا</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">فلوید وارشال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/4.html">پیدا کردن دور منفی در گراف</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">ماتریس ها</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">ماتریس مجاورت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">تعداد گشت ها به طول n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">به دست آوردن توابع بازگشتی به کمک گراف و ماتریس</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">داده ساختار های درختی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">BST</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">Segment tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">MST</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">Kruskal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Prim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Buvrika</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">شرح مساله</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">راه حل O(n+q*lg(n)) به کمک جداسازی سبک-سنگین</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">الگوریتم برون‌خط تارجان</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">ارتباط LCA و RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">راه خطی برای LCA</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">الگوریتم های پیشرفته درخت</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">سنتروید</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">گونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">اچ ال دی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">هافمن کدینگ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">هش درخت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">همبندی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">برش ها و همبندی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">گراف k همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">برش کمینه و جریان بیشینه</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">تطابق</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">آشنایی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">تطابق در گراف دوبخشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">قضایا ی مینماکس</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">کاربرد ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">جریان بیشینه و تطابق</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">تطابق در گراف های عام</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">مباحث ویژه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">گراف مسطح</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">دنباله درجه ای</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">رنگ آمیزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">یک ریختی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">اعداد رمزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">چند جمله ای گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">مجموعه مستقل و خوشه</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">2sat</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">ضمیمه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">چگونه از این کتاب استفاده کنیم؟</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">آشنایی با الگوریتم ها و پیچیدگی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">برگه تقلب (Cheat sheet)</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; فهرست</a>&nbsp;
        <a><i class="fa  fa-angle-left"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; فاصله در درخت و گراف</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;سوالات</a>
        
            <a href="../../_sources/book/2/2.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; سورس</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <div class="section" id="id1">
<h1>فاصله در درخت و گراف<a class="headerlink" href="#id1" title="لینک ثابت به این سر مقاله">¶</a></h1>
<p>در این بخش با معرفی فاصله در گراف به بررسی تعریف های مرتبط با فاصله چه در حالت کلی و چه در حالت خاص آن(یعنی در درخت) میپردازیم. در درخت ها صحبت در مورد فاصله به مراتب راحت تر از گراف در حالت کلی است چرا که همانطور که در بخش قبل بررسی کردیم در درخت مسیر بین هر دو راس یکتا است.</p>
<div class="section" id="id2">
<h2>فاصله چیست؟<a class="headerlink" href="#id2" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>دو راس <span class="math">\(u,v\)</span> در گراف را در نظر بگیرید. فاصله این دو راس طول (تعداد یال ها) کوتاه ترین مسیر بین این دو راس تعریف می شود.</p>
<p>نکته : اگر دو راس در دو مولفه همبندی جدا باشند فاصله آن ها بینهایت است.</p>
<p>فاصله دو راس <span class="math">\(u,v\)</span> را به صورت <span class="math">\(d(u,v)\)</span> نشان میدهند.</p>
</div>
<div class="section" id="id3">
<h2>قطر<a class="headerlink" href="#id3" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>تعریف : قطر گراف برابر است با <span class="math">\(Max_{u,v}\)</span> <span class="math">\(d(u,v)\)</span> یا به عبارتی ماکسیمم فاصله دو به دو راس ها در گراف.</p>
<p>توجه کنید که قطر بلندترین مسیر نیست و در واقع بلند ترین <strong>فاصله</strong> است ولی در درخت بلندترین مسیر و قطر یکی است زیرا اگر دو سر بلندترین مسیر را بگیرید
چون بین آن دو دقیقا یک مسیر وجود دارد و بلندترین مسیر , آن مسیر است در واقع طول بلندترین مسیر برابر فاصله آن دو راس است پس قطر برابر بلندترین مسیر است.
تفاوت بلند ترین مسیر و قطر جایی به چشم می اید که در حالت کلی  پیدا کردن قطر یک گراف از اوردر چند جمله ای حل میشود ولی پیدا کردن بلند ترین مسیر یک مسئله NP است.</p>
</div>
<div class="section" id="id4">
<h2>خروج از مرکز<a class="headerlink" href="#id4" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>اگر نام راس را <span class="math">\(u\)</span> در نظر بگیریم خروج از مرکز <span class="math">\(u\)</span> برابر ماکسیمم <span class="math">\(d(u,v)\)</span> به ازای همه <span class="math">\(v\)</span> هاست.</p>
<p>گراف اگر درخت باشد و درخت را از <span class="math">\(u\)</span> اویزان کنیم خروج از مرکز <span class="math">\(u\)</span> میشود ارتفاع راسی که بیشترین ارتفاع را در درخت دارد.</p>
<p>خروج از مرکز راس <span class="math">\(u\)</span> را با  <span class="math">\(\varepsilon{(u)}\)</span>  نشان میدهند.</p>
</div>
<div class="section" id="id5">
<h2>قضیه 2.2.1<a class="headerlink" href="#id5" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>صورت قضیه : در درخت خروج از مرکز یک راس برابر ماکسیمم فاصله آن از دو سر قطر است.</p>
<p>اثبات : برهان خلف میزنیم. فرض کنید راس ما <span class="math">\(a\)</span>  است و دو سر قطر هم راس های <span class="math">\(u , v\)</span> هستند . و راسی که فاصله اش با <span class="math">\(a\)</span> برابر <span class="math">\(\varepsilon(a)\)</span> است <span class="math">\(b\)</span> نام دارد . واضح هم است <span class="math">\(a\)</span> اگر یکی از دو سر قطر بود حکم درست است پس فرض میکنیم هیج یک از دو سر قطر نیست.</p>
<p>درخت را از <span class="math">\(a\)</span> آویزان میکنیم. فرض کنید راس <span class="math">\(mh\)</span> راسی با بیشترین ارتفاع باشد که سه راس <span class="math">\(b,u,v\)</span> داخل زیر درخت آن هستند.
چون <span class="math">\(mh\)</span> بیشترین ارتفاع از پدر های مشترک این سه راس دارد یعنی یا <span class="math">\(mh = b\)</span> است یا بچه ای از <span class="math">\(mh\)</span> که جد <span class="math">\(b\)</span> است در زیر درختش حداقل یکی از دو راس
<span class="math">\(u , v\)</span> را ندارد.که یعنی <span class="math">\(mh = lca(u,b)\)</span>  or <span class="math">\(lca(v,b)\)</span> .بدون از دست دادن کلیت مسئله فرض کنید <span class="math">\(mh = lca(u,b)\)</span>. حال ثابت میکنیم <span class="math">\(d(b,u)\)</span> &gt; <span class="math">\(d(u,v)\)</span>
با اثبات این بخش با تناقض بدست امده در طول قطر قضیه اثبات میشود.</p>
<ul class="simple">
<li><span class="math">\(d(b,u)\)</span> &gt; <span class="math">\(d(u,v)\)</span></li>
<li><span class="math">\(mh = lca(b,u)\)</span> <span class="math">\(\longrightarrow\)</span>  <span class="math">\(h(b)+h(u)-2×h(Mh)\)</span> &gt; <span class="math">\(d(u,v)\)</span></li>
<li>اگر <span class="math">\(mh \neq lca(u,v)\)</span> هم باشد باز جد مشترکشان است پس <span class="math">\(d(u,v)\)</span> <span class="math">\(\leqslant\)</span> <span class="math">\(h(u)+h(v)-2×h(mh)\)</span></li>
<li>در نتیجه</li>
</ul>
<dl class="docutils">
<dt><span class="math">\(h(B) + h(u) - 2×h(mh) &gt; h(u) + h(v) - 2×h(mh) \longrightarrow h(B) &gt; h(u)\)</span></dt>
<dd>که فرض سوال است پس عبارت درست است. با تناقض بدست امده قضیه اثبات شد.</dd>
</dl>
</div>
<div class="section" id="id6">
<h2>شعاع و مرکز<a class="headerlink" href="#id6" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>به راسی که مینیمم خروج از مرکز را را در بین راس های گراف دارد مرکز گراف گوییم و به خروج از مرکز آن شعاع گراف.</p>
</div>
<div class="section" id="id7">
<h2>قضیه 2.2.2<a class="headerlink" href="#id7" title="لینک ثابت به این سر مقاله">¶</a></h2>
<ul class="simple">
<li>الف) در درخت اگر قطر برابر <span class="math">\(Q\)</span> باشد شعاع برابر <span class="math">\(\lceil{Q/2}\rceil\)</span> است.</li>
<li>ب) در درخت اگر <span class="math">\(Q\)</span> فرد باشد دو راس وسط مسیر دو سر قطر مرکز هستند و اگر زوج باشد راس وسط قطر.</li>
</ul>
<p>اثبات : در ابتدا ثابت میکنیم راسی که در مسیر دو سر قطر نیست نمیتواند مرکز باشد. راسی مانند <span class="math">\(u\)</span> را در نظر بگیرید که در مسیر دو سر قطر نیست و راس <span class="math">\(v\)</span> را راسی از مسیر دو سر قطر در نظر بگیرید که فاصله اش با
<span class="math">\(u\)</span> مینیمم است با توجه به قضیه 2.2.1 میتوان فهمید <span class="math">\(\varepsilon{(u)} = \varepsilon{(v)} + d(u,v)\)</span> پس <span class="math">\(v\)</span> قطعا مرکز نیست.
حال بیایبد راس های درون مسیر دو سر قطر را از یک سر قطر به ترتیب شماره گزاری کنید(یعنی از 0 تا <span class="math">\(Q\)</span>. طبق  قضیه 2.2.1 میدانیم راس خروج از مرکز راس <span class="math">\(i\)</span> ام در مسیر دو سر قطر برابر <span class="math">\(max(i,Q-i)\)</span>
است.میدانیم مینیمم عبارت بالا زمانی است که <span class="math">\(i , Q-i\)</span> کمترین اختلاف را با هم داشته باشند پس</p>
<ul class="simple">
<li>اگر <span class="math">\(Q\)</span> زوج باشد جواب میشود  <span class="math">\(min(Q - Q/2 , Q/2)\)</span> = <span class="math">\(Q/2\)</span>  پس شعاع برابر <span class="math">\(Q/2\)</span> است و تنها مرکز هم راس وسط قطر است (راس <span class="math">\(Q/2\)</span> مسیر دو سر قطر.</li>
<li>اگر <span class="math">\(Q\)</span> فرد باشد شعاع میشود  <span class="math">\(min((Q-1)/2 , (Q+1)/2)\)</span> = <span class="math">\((Q+1)/2\)</span>  و تنها راس هایی در مسیر در سر قطر که چنین ویژگی دارد راس های <span class="math">\((Q-1)/2,(Q+1)/2\)</span>  مسیر دو سر قطر هستند.</li>
</ul>
</div>
<div class="section" id="id8">
<h2>سنتروید<a class="headerlink" href="#id8" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>به راسی در گراف که مجموع فاصله هایش از دیگر راس ها مینیمم است سنتروید گراف میگویند . به مانند تعاریف بالا سنتروید در درخت نیز دارای ویژگی جالبی است که در قضیه زیر آمده.</p>
</div>
<div class="section" id="id9">
<h2>قضیه 2.2.3<a class="headerlink" href="#id9" title="لینک ثابت به این سر مقاله">¶</a></h2>
<ul class="simple">
<li>الف) در درخت یک راس سنتروید است اگر و تنها اگر وقتی او را از درخت حذف کنیم سایز هر مولفه کمتر مساوی <span class="math">\(n/2\)</span> باشد.</li>
<li>ب) در درخت حداکثر دو سنتروید داریم و اگر دو تا باشند گراف زوج راسی است و ان دو به هم یال دارند .</li>
</ul>
<p>اثبات : راس ها را شماره گزاری میکنیم و <span class="math">\(a_i\)</span> برابر مجموع فاصله های راس <span class="math">\(i\)</span> از دیگر راس های خواهد بود.حال ابتدا بخش اگر الف را اثبات میکنیم. فرض کنید سنتروید راس <span class="math">\(u\)</span> باشد و وقتی ان را حذف کنیم
مولفه همبندی با سایز بیشتر از <span class="math">\(n/2\)</span> بوجود بیاید حال میگویم راسی که از ان مولفه با <span class="math">\(u\)</span> همسایه است را در نظر بگیرید و نام آن را <span class="math">\(v\)</span> بگزارید . فاصله <span class="math">\(v\)</span> از راس های داخل این مولفه همبندی
یکی کمتر از فاصله <span class="math">\(u\)</span> از ان ها است و برای دیگر راس ها هم فاصله آن یکی بیشتر از فاصله <span class="math">\(u\)</span> است پس <span class="math">\(a_v = a_u - sz + (n-sz)\)</span> که <span class="math">\(sz\)</span> برابر سایز آن مولفه همبندی است.
و چون <span class="math">\(sz &gt; n/2\)</span> <span class="math">\(\longrightarrow\)</span> <span class="math">\(n - 2×sz &lt; 0\)</span> <span class="math">\(\longrightarrow\)</span> <span class="math">\(a_v &gt; a_u\)</span> با تناقض بدست امده اگر الف اثبات شد.</p>
<p>حال ثابت میکنم هر دو راسی مانند <span class="math">\(i , j\)</span> که ویژگی اگر بخش الف را دارند در ان ها <span class="math">\(a_i = a_j\)</span> و چون میدانیم سنتروید ما ویژگی اگر الف را دارد پس همه راس ها با ویژگی اگر الف سنتروید هستند.
درخت را از راس <span class="math">\(i\)</span> اویزان میکنیم.حال یک متغیر به نام <span class="math">\(A\)</span> داریم که وقتی روی راس <span class="math">\(z\)</span> هستیم <span class="math">\(A = a_z`و اول کار :math:`A = a_i\)</span> حال از راس ریشه یعنی <span class="math">\(i\)</span> به سمت راس <span class="math">\(j\)</span> حرکت میکنیم
(یعنی در واقع مسیر بین این دو راس را با شروع از <span class="math">\(i\)</span> طی میکنیم) حال زمانی که از یک راس به بچه اش میرویم <span class="math">\(A\)</span> به اندازه سایز زیر درخت بچه اش کم میشود و به اندازه تعداد راس های منهای سایز زیر درخت بچه اش به <span class="math">\(A\)</span> اضافه میشود.</p>
<blockquote>
<div>ما میدانیم سایز زیر درخت <span class="math">\(j\)</span> بیشترمساوی از <span class="math">\(n/2\)</span> است زیرا وقتی <span class="math">\(j\)</span> را از درخت حذف کنیم سایز مولفه همبندی که پدرش در آن قرار دارد طبق فرض کمتر مساوی <span class="math">\(n/2\)</span> است پس تعداد راس های که در این مولفه نیستند(با احتساب <span class="math">\(j\)</span>)</div></blockquote>
<p>بیشتر مساوی <span class="math">\(n/2\)</span> است.پس سایز زیر درخت تمام جد های <span class="math">\(j\)</span> که ما طی کردیم هم این بیشتر مساوی بیشتر مساوی <span class="math">\(n/2\)</span> است پس میتوان نتیجه گرفت مقدار <span class="math">\(A\)</span> همیشه یا کمتر میشود یا تغییر نمیکند.
پس :math:` a_i &gt;= a_j <cite>. اگر ما درخت را از :math:`j</cite> هم اویزان کنیم و مسیر بین ان دو را طی کنیم به نتیجه :math:` a_j geq a_i ` میرسیم که در نتیجه <span class="math">\(a_i = a_j\)</span> است.</p>
<p>حال به اثبات بخش ب میرویم فرض کنید دو راس <span class="math">\(i,j\)</span> سنتروید هستند و درخت را از  <span class="math">\(i\)</span> اویزان کردیم و داریم الگوریتم بالا را طی میکنیم حال میگوییم وقتی از یک راس به بچه اش میرویم <span class="math">\(A\)</span> در صورتی تغییر نمیکند
که سایز زیر درخت بچه دقیقا برابر <span class="math">\(n/2\)</span> باشد و چون سایز زیر درخت <span class="math">\(j\)</span> بیشتر مساوی از <span class="math">\(\lceil{n/2}\rceil\)</span> است پس باید برای آن که <span class="math">\(A\)</span> در کل مسیر تغییر نکند <span class="math">\(j\)</span> بچه
<span class="math">\(i\)</span> باشد و سایز زیر درختش  دقیقا <span class="math">\(n/2\)</span> باشد . پس درخت زوج راسی است زیرا سایز زیر درخت <span class="math">\(j\)</span> بیشتر مساوی <span class="math">\(\lceil{n/2}\rceil\)</span> است و سایز زیر درخت بچه های
<span class="math">\(i\)</span> باید کمتر مساوی <span class="math">\(\lfloor{n/2}\rfloor\)</span> باشد پس باید <span class="math">\(\lfloor{n/2}\rfloor = \lceil{n/2}\rceil ` باشد پس :math:`n\)</span> زوج است.
همچنین فهمیدیم در بالا هر دو سنتروید با هم همسایه اند پس واضح است که حداکثر میتوانیم دو سمنترید داشته باشیم و اگر نه دور داریم.</p>
</div>
<div class="section" id="id10">
<h2>مجموع فاصله ها<a class="headerlink" href="#id10" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>فرض کنید در مسئله ای هدف مینیمم یا ماکسیمم کردن مجموع فاصله بین هر دو راس است فرض کنید به این مجموع چگالی گراف بگوییم. به صورت شهودی هر چه چگالی گراف کمتر باشد گراف جمع و جور تر و هر چه چگالی گراف بیشتر باشد گراف پهن و پخش تر است.</p>
<p>در ضمن برای اینکه فاصله تعریف شده باشد فرض کنید موضوع بحث ما گراف های همبند می باشد.</p>
<div class="section" id="id11">
<h3>کمینه کردن چگالی گراف<a class="headerlink" href="#id11" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>فاصله بین دو راس حداقل 1 است. و در گراف <span class="math">\(K_n\)</span> فاصله بین هر دو راس دقیقا 1 است. پس کمترین چگالی ممکن در گراف <span class="math">\(K_n\)</span> به دست می آید که برابر با <span class="math">\(n \choose 2\)</span> می باشد.</p>
<p>حالا اگر دامنه بحث را به درخت ها محدود کنیم مسئله کمی سخت تر می شود. اما همچنان می توان اینگونه استنتاج کرد.</p>
<ul class="simple">
<li>دقیقا <span class="math">\(n-1\)</span> جفت از راس ها هستند که فاصله اشان دقیقا 1 است. زیرا درخت <span class="math">\(n-1\)</span> یال دارد.</li>
<li>هر جفتی از راس ها که به همدیگر یال ندارند دارای فاصله حداقل 2 هستند.</li>
</ul>
<p>در نتیجه کمترین چگالی ممکن حداقل <span class="math">\(2 \times {n \choose 2} - (n-1)\)</span> می باشد و تنها مثالی که در حالت این کران صدق می کند حالتی است که فاصله بین هر دو راس <strong>حداکثر</strong> برابر با 2 است. تنها درختی که این ویژگی را دارد ستاره می باشد (همانطور که در عکس می بینید). زیرا که اگر در این گراف دو برگ باشند که پدر مشترک نداشته باشند در اینصورت فاصله آنها حداقل 3 خواهد بود.</p>
<blockquote>
<div><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/star.png"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/star.png" style="width: 50%;" /></a>
</div>
</div></blockquote>
</div>
<div class="section" id="id12">
<h3>بیشینه کردن چگالی گراف<a class="headerlink" href="#id12" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>در این حالت توجه کنید که اگر یالی را حذف کنیم و حذف این یال گراف را ناهمبند نکند باید اینکار را بکنیم. زیرا که حذف یال باعث بیشتر شدن چگالی می شود (چرا؟). پس گرافی که چگالی آن بیشینه است را باید در میان درخت ها جست و جو کرد (زیرا همانطور که گفتیم همه یال های آن باید برشی باشد).</p>
<p>حالا یک راس خاص مثل <span class="math">\(u\)</span> را در نظر بگیرید. ادعا می کنیم جمع فواصل همه راس ها از <span class="math">\(u\)</span> حداکثر برابر با <span class="math">\(n \choose 2\)</span> است.</p>
<p>برای اثبات فرض کنید درخت را از <span class="math">\(u\)</span> آویزان کرده ایم و به ازای هر ارتفاع می دانیم که چند راس در این ارتفاع قرار دارند و بیشترین ارتفاع <span class="math">\(H\)</span> باشد. در اینصورت به ازای هر ارتفاعی از 0 تا <span class="math">\(H\)</span> حداقل یک راس از این ارتفاع باید داشته باشیم. حالا اگر حداقل دو راس در یک ارتفاع داشتیم می توان یکی از آن ها را به ارتفاع بالاتر برد و در اینصورت جمع ارتفاع ها بیشتر خواهد شد. با تکرار این فرایند به حالتی می رسیم که در هر ارتفاع 0 تا <span class="math">\(n-1\)</span> دقیقا یک راس باشد (یعنی درخت یک مسیر شده) که در این حالت جمع فاصله ها از <span class="math">\(u\)</span> برابر با <span class="math">\(1 + 2 + ... + (n-1) = {n \choose 2}\)</span> خواهد بود. پس ثابت کردیم که جمع فاصله ها از هر راس <span class="math">\(u\)</span> حداکثر <span class="math">\(n \choose 2\)</span> است.</p>
<p>پس حالا برای اینکه به یک کران برسیم در هر مرحله یک <strong>برگ</strong> را از درخت حذف کنید و جمع فاصله ها از این برگ را محاسبه کنید. جمع تمام مقادیر برابر با چگالی گراف خواهد بود که طبق آنچه گفتیم حداکثر <span class="math">\(\sum\limits_{i=1}^{n} {i \choose 2} = {{n+1} \choose 3}\)</span> خواهد بود (طبق اتحاد چوشی چی).</p>
<p>می توان نتیجه گرفت تنها گرافی که در حالت تساوی این کران صدق می کند گراف مسیر است.</p>
</div>
</div>
<div class="section" id="id13">
<h2>درخت پشتیبانی<a class="headerlink" href="#id13" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>فرض کنید یک شبکه ارتباطی داریم که <span class="math">\(n\)</span> شهر را به هم وصل می کنند. برای اطمینان یک شبکه ارتباطی پشتیبانی هم آماده کرده ایم که در صورت ایجاد اختلال در شبکه اصلی از شبکه پشتیبانی استفاده کنیم تا ارتباط قطع نشود.</p>
<p>به زبان گراف دو درخت <span class="math">\(n\)</span> راسی <span class="math">\(T\)</span> و <span class="math">\(T ^ {\prime}\)</span> داریم. می خواهیم ثابت کنیم در صورتیکه یکی از یال های <span class="math">\(T\)</span> مثل <span class="math">\(uv\)</span> قطع شوند می توان یکی از یال های <span class="math">\(T ^ {\prime}\)</span> مثل <span class="math">\(u^{\prime}v^{\prime}\)</span> را به درخت <span class="math">\(T\)</span> اضافه کرد که ساختار همچنان همبند باقی بماند.</p>
<p>پس فرض کنید <span class="math">\(uv\)</span> را از <span class="math">\(T\)</span> حذف کردیم در اینصورت درخت ما دارای دو مولفه همبندی خواهد شد یکی از مولفه ها را آبی و دیگری را قرمز در نظر بگیرید. حالا می توان در درخت <span class="math">\(T^{\prime}\)</span> مسیری بین <span class="math">\(u,v\)</span> یافت.
در این مسیر یالی وجود خواهد داشت که یک سر آن آبی و یک سر آن قرمز باشد (چرا؟). حالا اگر این یال <span class="math">\(u^{\prime}v^{\prime}\)</span> باشد می توانیم این یال را به <span class="math">\(T\)</span> اضافه کنیم و دوباره آن را همبند کنیم!</p>
</div>
<div class="section" id="id14">
<h2>افراز درخت به مسیر ها<a class="headerlink" href="#id14" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>درخت <span class="math">\(T\)</span> را در نظر بگیرید. در این قسمت هدف ما این است که یال های این درخت را به کمترین تعداد تعدادی مسیر افراز کنیم. برای شهود بهتر فرض کنید یال های مسیر ها را یکی یکی از درخت حدف می کنیم تا به گرافی بدون یال برسیم.</p>
<p>اول از همه توجه کنید که بعد از حذف هر مسیر تنها زوجیت درجه دو سر مسیر تغییر می کند همچنین در انتها درجه تمام راس ها زوج (صفر) خواهد بود. پس یک راس درجه فرد باید فرد بار و یک راس درجه زوج باید زوج بار به عنوان یک سر مسیر انتخاب شود. پس اگر تعداد راس های درجه فرد درخت <span class="math">\(X\)</span> باشد آنگاه حداقل <span class="math">\(\frac X 2\)</span> مسیر نیاز داریم. (می دانیم که تعداد راس های درجه فرد هر گرافی زوج است پس <span class="math">\(X\)</span> زوج است).</p>
<p>حالا اگر در هر مرحله مسیر بین دو راس درجه فرد را حذف کنیم می توانیم به حالت بهینه برسیم! فقط باید توجه داشته باشیم که دو راس درجه فرد ما مربوط به یک مولفه همبندی باشد.</p>
<p>حالا سوالی که پیش می آید این است که درخت بودن طی این فرایند به ما چه کمکی کرد؟</p>
<p>در نهایت ما از این موضوع استفاده کردیم که اگر درختی راس درجه فرد نداشته باشد یالی ندارد (اما این قضیه در گراف به صورت کلی برقرار نیست). چرا که اگر تعداد راس های گراف حداقل دو باشد در اینصورت برگی خواهد داشت که درجه آن 1 (و فرد) است.</p>
</div>
<div class="section" id="id15">
<h2>پوشاندن یال های درخت با مسیر ها<a class="headerlink" href="#id15" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>در ابن قسمت می خواهیم کمترین تعداد مسیر را پیدا کنیم که اجتماع آن ها کل یال های <span class="math">\(T\)</span> را شامل شود. این مسئله مشابه حالت قبل است با این تفاوت که در حالت قبل یال ها را به مسیر ها افراز می کردیم یعنی هر یال متعلق به یک مسیر بود. در اینجا این آزادی را داریم که یک مسیر چند بار یالی را بپوشاند. می توان نتیجه گرفت که جواب این مسئله کمتر از مسئله قبل است.</p>
<p>در نگاه اول متوجه می شوید که چون طولانی کردن مسیر ها ضرری با ما نمی زند پس حالت بهینه ای وجود دارد که دو سر هر مسیر برگ باشد!</p>
<p>از طرف دیگر به ازای هر برگ یالی که از این برگ به راس مجاورش می رود را در نظر بگیرید. هر مسیر حداکثر 2 تا از این یال ها را می پوشاند. پس اگر <span class="math">\(X\)</span> تا برگ داشته باشیم حداقل <span class="math">\(\frac X 2\)</span> تا مسیر نیاز داریم حالا تلاش می کنیم تا این کران را بر آورده کنیم. یعنی اگر <span class="math">\(X\)</span> زوج باشد با <span class="math">\(\frac X 2\)</span> مسیر و اگر <span class="math">\(X\)</span> فرد بود با <span class="math">\(\frac {X+1} 2\)</span> مسیر یال های درخت را بپوشانیم.</p>
<p>پس سعی می کنیم در هر مرحله پس از انتخاب مسیر درختمان را به درختی تبدیل کنیم که تعداد برگ هایش دو تا کمتر است(البته در حالتی که <span class="math">\(X\)</span> فرد باشد مرحله آخر نمی توانیم اینکار را بکنیم). اگر بتوانیم این کار را بکنیم تعداد مسیر هایی که انتخاب کردیم نصف تعداد برگ ها خواهد بود همانطور که می خواستیم.</p>
<p>دو برگ دلخواه مثل <span class="math">\(u,v\)</span> را در نظر بگیرید و درخت را از این مسیر آویزان کنید. ابتدا این مسیر را انتخاب کنید (که یال های بین <span class="math">\(u,v\)</span> را بپوشاند). فرض کنید راس های مسیر ما <span class="math">\(a_1,...,a_k\)</span> باشد حالا درختی می سازیم که به جای <span class="math">\(a_1,...,a_k\)</span> یک راس دارد! بین این راس و یک راس مثل <span class="math">\(w\)</span> یال است اگر و تنها اگر بین <span class="math">\(w\)</span> و یکی از <span class="math">\(a_1,...,a_k\)</span> یال باشد.‌ (به صورت شهودی مثل این است که کل راس های مسیر را فشرده کردیم و به یک راس تبدیل کردیم). حالا هر مسیر در گراف جدیدمان معادل با یک مسیر در گراف اولیه است و الان تنها کافیست کل یال ها در درخت جدید را با مسیر ها بپوشانیم!</p>
<blockquote>
<div><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/compress.png"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/compress.png" style="width: 50%;" /></a>
</div>
</div></blockquote>
<p>پس در هر مرحله یک مسیر که دو سر آن برگ است را فشرده می کنیم و به صورت یک راس در می آوریم. در هر مرحله تعداد برگ های گراف جدیدمان دو تا کم می شود مگر اینکه راسی که جدید اضافه کردیم (راس فشرده) برگ باشد. در صورتی این اتفاق می افتد که راس های مسیر بین <span class="math">\(u,v\)</span> همه درجه 2 باشند به جز یکی از آنها که باید درجه 3 باشد. به <span class="math">\(u,v\)</span> که مسیر بین آن چنین خاصیتی داشته باشد یک زوج ناسازگار می گوییم.</p>
<p>پس اگر بتوانیم در هر مرحله دو برگ <span class="math">\(u,v\)</span> را طوری انتخاب کنیم که زوج ناسازگار نباشند این کار را می کنیم (‌که پس از فشرده سازی از تعداد برگ ها 2 تا کم می کند). اگر نتوانستیم اینکار را بکنیم چه؟ در اینصورت ادعا می کنیم تنها یک راس درجه 3 داریم و باقی راس ها دارای درجه 1 یا 2 هستند (چرا؟). در اینصورت همانطور که در شکل می بینید درخت ما دقیقا 3 برگ خواهد داشت و می توانیم آن را با 2 مسیر بپوشانیم.</p>
<blockquote>
<div><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/sepaye.png"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/sepaye.png" style="width: 50%;" /></a>
</div>
</div></blockquote>
</div>
<div class="section" id="id16">
<h2>درخت چپانی<a class="headerlink" href="#id16" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>فرض کنید درختی <span class="math">\(n\)</span> راسی به نام <span class="math">\(T\)</span> داریم. همچنین گرافی مثل <span class="math">\(G\)</span> داریم که <span class="math">\(\delta(G) \geq n-1\)</span>. می خواهیم ثابت کنیم زیرمجموعه ای از یال های <span class="math">\(G\)</span> وجود دارد که <span class="math">\(T\)</span> را بسازد. (به صورت شهودی یک درخت <span class="math">\(T\)</span> در گراف <span class="math">\(G\)</span> بتوان پیدا کرد).</p>
<p>یک برگ دلخواه مثل <span class="math">\(u\)</span> که تنها مجاور آن <span class="math">\(v\)</span> است را در نظر بگیرید و <span class="math">\(u\)</span> را از درخت حذف کنید! سپس به صورت استقرایی درخت <span class="math">\(T-u\)</span> را در <span class="math">\(G\)</span> پیدا کنید. حالا می خواهیم یال <span class="math">\(uv\)</span> را به درختمان اضافه کنیم. فرض کنید راس <span class="math">\(v\)</span> در گراف <span class="math">\(G\)</span> متناظر با <span class="math">\(v^{\prime}\)</span> شده باشد. حالا کافیست از بین مجاور های <span class="math">\(v^{\prime}\)</span> راسی را انتخاب کنید که قبلا با هیچ راس درخت متناظر نشده است. سپس می توان این راس را متناظر با <span class="math">\(u\)</span> قرار داد که فرض استقرای ما را ثابت می کند.</p>
<p>برای یافتن چنین راسی کافیست از فرض <span class="math">\(\delta(G) \geq n-1\)</span> استفاده کنیم. پس <span class="math">\(v^{\prime}\)</span> حداقل <span class="math">\(n-1\)</span> مجاور دارد و حداکثر <span class="math">\(n-2\)</span> تا از آن ها قبلا به راس های درخت متناظر شده اند. پس یکی از مجاور های <span class="math">\(v\)</span> تا حالا به راس های درخت متناظر نشده که حالا می توانیم همانطور که گفتیم <span class="math">\(u\)</span> را به آن متناظر کنیم.</p>
<p>این مسئله به منظور آشنایی شما با ساختار استقرا پذیر درخت مطرح شد. دیدید که چطور می توان یک برگ از درخت را حذف کرد و فرض استقرا را برای درخت باقی مانده به کار برد.</p>
</div>
</div>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="1.html" style="float:right;" title="خاصیت های مقدماتی" accesskey="p"><i class="fa fa-chevron-right"></i>&nbsp; قبلی</a>
                    
                    
                    <a href="4.html" style="float:left;" title="شمردن تعداد درخت ها" accesskey="n">بعدی &nbsp;<i class="fa fa-chevron-left"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/"><img src="/_static/shaazzz_logo.png"></a>
            </div>
            <div id="text">
                <p>
                    این کتاب توسط 
                    <a href="/contributors">
                    مشارکت کنندگان شاززز
                    </a>
                    به وجود آمده است.
                </p>
                <p>
                    این کتاب عمومی است و تحت پروانه cc-by-sa در دسترس است.
                </p>
                    <p style="font-size: 13px;">
                        آخرین به روز رسانی در سپتامبر 12, 2020.
                    </p>
                <p style="font-size: 13px;">
                    
                        ساخته شده به وسیله <a href="http://sphinx-doc.org/">Sphinx</a> (1.6.7) و <a href="https://github.com/saeiddrv/SphinxMinooTheme">تم مینو</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>
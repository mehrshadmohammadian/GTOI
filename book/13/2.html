

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="rtl" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


    
         <title>تطابق در گراف دوبخشی &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-rtl.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="تطابق" href="index.html" />
        <link rel="next" title="قضایا ی مینماکس" href="3.html" />
        <link rel="prev" title="آشنایی" href="1.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-left " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="جستجو">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">تعاریف اولیه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">مقدمات و مدل سازی با گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">انواع گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">پیاده سازی گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">گشت، گذر، مسیر، اکسترمال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">زیرگراف ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">همبندی، یال برشی و راس برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/7.html">گراف دو بخشی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../2/index.html">درخت ها</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../2/1.html">خاصیت های مقدماتی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/2.html">فاصله در درخت و گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/4.html">شمردن تعداد درخت ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/5.html">dfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/6.html">bfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/7.html">الگوریتم پیدا کردن قطر درخت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/8.html">الگوریتم های راس و یال برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/9.html">کارگاه پرورش ایده</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">گراف جهت‌دار</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">تعاریف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">تورنومنت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">گراف جهت‌دار بدون دور</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html">مولفه‌های قویا همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">تشخیص دور داشتن گراف جهت دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">بازی‌ها و گراف جهت‌دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">گراف تابعی و گراف جایگشت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">تکنیک های اثبات مسائل گراف</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">انتخاب های اکسترمالی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">منقبض کردن</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">گراف و جادو</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">تور اویلری و دور همیلتونی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">معرفی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">تور اویلری در گراف جهت دار و بی جهت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">قضیه های وجودی دور همیلتونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">الگوریتم های نمایی پیدا کردن دور و مسیر همیلتونی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">الگوریتم های کوتاه ترین مسیر</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">بلمن فورد</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">دکسترا</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">فلوید وارشال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/4.html">پیدا کردن دور منفی در گراف</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">ماتریس ها</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">ماتریس مجاورت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">تعداد گشت ها به طول n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">به دست آوردن توابع بازگشتی به کمک گراف و ماتریس</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">داده ساختار های درختی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">BST</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">Segment tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">MST</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">Kruskal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Prim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Buvrika</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">شرح مساله</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">راه حل O(n+q*lg(n)) به کمک جداسازی سبک-سنگین</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">الگوریتم برون‌خط تارجان</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">ارتباط LCA و RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">راه خطی برای LCA</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">الگوریتم های پیشرفته درخت</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">سنتروید</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">گونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">اچ ال دی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">هافمن کدینگ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">هش درخت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">همبندی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">برش ها و همبندی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">گراف k همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">برش کمینه و جریان بیشینه</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">تطابق</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">آشنایی</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">تطابق در گراف دوبخشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">قضایا ی مینماکس</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">کاربرد ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">جریان بیشینه و تطابق</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">تطابق در گراف های عام</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">مباحث ویژه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">گراف مسطح</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">دنباله درجه ای</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">رنگ آمیزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">یک ریختی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">اعداد رمزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">چند جمله ای گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">مجموعه مستقل و خوشه</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">2sat</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">ضمیمه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">چگونه از این کتاب استفاده کنیم؟</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">آشنایی با الگوریتم ها و پیچیدگی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/3.html">برگه تقلب (Cheat sheet)</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; فهرست</a>&nbsp;
        <a><i class="fa  fa-angle-left"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; تطابق در گراف دوبخشی</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;سوالات</a>
        
            <a href="../../_sources/book/13/2.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; سورس</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <div class="section" id="id1">
<h1>تطابق در گراف دوبخشی<a class="headerlink" href="#id1" title="لینک ثابت به این سر مقاله">¶</a></h1>
<p>در بخش قبل گفتیم که شرط لازم و کافی برای داشتن یک تطابق ماکسیمم این است که مسیر افزوده وجود نداشته باشد. این شرط در گراف دوبخشی به راحتی قابل بررسی است (چرا؟).</p>
<p>در نتیجه بررسی کردن تطابق در گراف های دوبخشی (به عنوان حالت خاصی از گراف) به علت کاربرد زیادشان سودمند است.</p>
<div class="section" id="id2">
<h2>الگوریتم<a class="headerlink" href="#id2" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>در این الگوریتم از تطابق خالی شروع می‌کنیم و تا زمانی که مسیری افزایشی در گراف وجود داشت تطابق را بزرگ‌تر می‌کنیم. به راحتی قابل مشاهده است که در این صورت ماکسیمم بودن تطابق نهایی ما بدیهی است. برای پیدا کردن مسیر افزایشیبه این صورت عمل میکنیم:</p>
<p>فرض کنید گراف ما شامل دو بخش <span class="math">\(n_1\)</span> راسی و <span class="math">\(n_2\)</span> راسی باشد. به ازای <span class="math">\(v = 1 ... n_1\)</span> در گراف حال حاضرمان به دنبال مسیر افزایشی می‌گردیم. در مرحله <span class="math">\(i\)</span> ام می‌توان ادعا کرد تطابقی که بین <span class="math">\(i\)</span> راس بخش اول و بقیه رئوس بخش دوم است ماکسیمم است، در نتیجه در آخر نیز تطابق ما ماکسیمم خواهد بود. پیاده‌سازی آن به شکل زیر است:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="cm">/* In the name of Allah */</span>
<span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">2e3</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">match</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">mark</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">bool</span> <span class="nf">try_kuhn</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mark</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">v</span><span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">&amp;&amp;</span> <span class="n">try_kuhn</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">])))</span> <span class="p">{</span>
            <span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_input</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n1</span> <span class="o">&gt;&gt;</span> <span class="n">n2</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">adj</span><span class="p">[</span><span class="o">--</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="o">--</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calc</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">match</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">n1</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">mark</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">mark</span><span class="p">);</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="n">try_kuhn</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_output</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">match</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ios</span><span class="o">::</span> <span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">read_input</span><span class="p">(),</span> <span class="n">calc</span><span class="p">(),</span> <span class="n">write_output</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>در الگوریتم ذکر شده به ازای هر راس از بخش بالا، <span class="math">\(O(m)\)</span> گام انجام می‌شود، پس پیچیدگی زمانی آن برابر <span class="math">\(O(nm)\)</span> است. البته یک نوع پیاده‌سازی دیگر همین الگوریتم نیز وجود دارد که سرعت آن حداقل دوبرابر سریع‌تر از الگوریتم بالا است (چرا؟):</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="cm">/* In the name of Allah */</span>
<span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">2e3</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">match</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">mark</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">bool</span> <span class="nf">try_kuhn</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mark</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">v</span><span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">&amp;&amp;</span> <span class="n">try_kuhn</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">])))</span> <span class="p">{</span>
            <span class="n">match</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_input</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n1</span> <span class="o">&gt;&gt;</span> <span class="n">n2</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">u</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">adj</span><span class="p">[</span><span class="o">--</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="o">--</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">calc</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">match</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">mark</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">mark</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">n1</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mark</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="n">try_kuhn</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_output</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">match</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ios</span><span class="o">::</span> <span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">read_input</span><span class="p">(),</span> <span class="n">calc</span><span class="p">(),</span> <span class="n">write_output</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>قضیه هال<a class="headerlink" href="#id3" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>این قضیه شرط لازم و کافی دیگری برای ماکسیمم بودن یک تطابق در یک گراف دوبخشی را بیان می‌کند که اولین بار توسط فیلیپ هال مطرح شد و به قضیه ازدواج معروف است. این قضیه به شرح زیر است:</p>
<p>فرض کنید <span class="math">\(X\)</span> مجموعه‌ای از رئوس بخش اول یک گراف دوبخشی باشد. مجموعه <span class="math">\(X\)</span> در گراف تطابق کامل دارد، اگر و تنها اگر به ازای هر زیرمجموعه از آن مثل <span class="math">\(S\)</span> و مجموعه همسایه‌های خارج <span class="math">\(X\)</span> آن‌ها در گراف به نام <span class="math">\(T\)</span>، داشته باشیم <span class="math">\(|S| \leq |T|\)</span>.</p>
<p>لازم بودن شرط بالا بدیهی است (در غیر این صورت تعداد رئوس مجاور یک مجموعه برای تطابق دادنشان کافی نخواهد بود). برای اثبات کافی بودن نیز از برهان خلف استفاده می‌کنیم و فرض می‌کنیم گرافی با چنین خاصیتی باشد که تطابق کامل نداشته باشد؛</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/marriage_theorem.jpeg"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/marriage_theorem.jpeg" style="width: 50%;" /></a>
</div>
<p>یک تطابق ماکسیمم را درنظر می‌گیریم و راس دلخواهی مثل <span class="math">\(u\)</span> که غیراشباع است را درنظر می‌گیریم (حتماً وجود دارد!). از آنجا که این راس با کسی منطبق نشده، راس منطبق یک راس دلخواه مجاور آن را درنظر میگیریم. این دو راس طبق فرض مسئله یک راس مجاور دیگر دارند که یا منطبق نشده (که در این صورت مسیر افزایشی داریم) و یا منطبق شده که راس منطبق آن را نیز به این دو راس اضافه می‌کنیم. این کار را تا جای ممکن ادامه می‌دهیم و از آنجا که تعداد رئوس مجاور <span class="math">\(X\)</span> حداقل اندازه خودشان است، در آخر به مرحله‌ای میرسیم که مجموعه حال حاضرمان یک راس مجاور دارند که اشباع نشده که در این صورت مسیر افزایشی داریم که این با ماکسیمم بودن تطابقمان در تناقض است.</p>
</div>
<div class="section" id="k">
<h2>تطابق در گراف دوبخشی k منتظم<a class="headerlink" href="#k" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>طبق قضیه هال می‌توان اثبات کرد که گراف دوبخشی k منتظم تطابق کامل دارد. برای اثبات این موضوع نیز کافیست اثبات کنیم که شرط هال برای آن برقرار است؛</p>
<p>مجموعه‌ای از رئوس بخش اول گراف مثل <span class="math">\(S\)</span> را درنظر بگیرید و همسایه‌های آن‌ها در بخش دوم را <span class="math">\(T\)</span> بنامید. اثبات می‌کنیم <span class="math">\(|S| \leq |T|\)</span>. می‌دانیم مجموع یال‌های بین دو بخش برابر <span class="math">\(x = |S| \times k\)</span> است. از این رابطه می‌توان نتیجه گرفت <span class="math">\(|T| \geq (x \div k) = |S|\)</span>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/k_regular_matching.png"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/k_regular_matching.png" style="width: 50%;" /></a>
</div>
<p>پس حکم حال در گراف ما برقرار است و قطعاً در گراف ما تطابقی کامل یافت می‌شود.</p>
</div>
<div class="section" id="id4">
<h2>تعمیم قضیه هال<a class="headerlink" href="#id4" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>یک گراف دوبخشی به نام <span class="math">\(G\)</span> داریم و می‌خواهیم تعدادی از یال‌های آن را برداریم، طوری که درجه هر راس بخش اول مثل <span class="math">\(u\)</span> برابر <span class="math">\(a_u\)</span> و درجه هر راس بخش دوم حداکثر یک شود. برای حل این مسئله گراف <span class="math">\(G'\)</span> را به گونه‌ای میسازیم که در آن تطابق کامل از بخش اول به دوم وجود دارد، اگر و تنها اگر در گراف <span class="math">\(G\)</span> چنین مجموعه یال‌هایی وجود داشته باشد؛</p>
<p>گراف <span class="math">\(G'\)</span> را بدین گونه می‌سازیم که به جای هر راس <span class="math">\(u\)</span> در گراف از بخش اول، یک مجموعه <span class="math">\(a_u\)</span> تایی از رئوس می‌سازیم (که کپی هایی از راس <span class="math">\(u\)</span> هستند) و به ازای هر یال گراف مثل <span class="math">\((u, v)\)</span>، تمام مجموعه راس <span class="math">\(u\)</span> را به راس  <span class="math">\(v\)</span> متصل می‌کنیم. گراف حاصل دوبخشی است (چرا؟) اگر شرط هال در آن برقرار باشد یعنی تطابق کامل دارد که در این صورت به ازای هر یال بین مجموعه رئوس راس <span class="math">\(u\)</span> و راس <span class="math">\(v\)</span> در گراف، یال <span class="math">\((u, v)\)</span> را در گراف <span class="math">\(G\)</span> برمی‌داریم که بدیهی است که در این صورت به مجموعه یال‌های دلخواهمان می‌رسیم. در صورتی هم که گراف <span class="math">\(G'\)</span> تطابقی کامل نداشته باشد به همین شکل می‌توان نتیجه گرفت که در گراف <span class="math">\(G\)</span> نیز چنین مجموعه‌ای وجود ندارد (به صورت برعکس عمل میکنیم).</p>
<p>فرایند چک کردن شرط هال در گراف <span class="math">\(G^{\prime}\)</span> را در نظر بگیرید.به ازای هر زیرمجموعه <span class="math">\(S\)</span> که از بخش اول گراف <span class="math">\(G ^ {\prime}\)</span> و مجموعه همسایه های آن <span class="math">\(T\)</span> است، چک می کنیم که <span class="math">\(|S| \leq |T|\)</span> برقرار باشد. حالا می توان توجه کرد که به ازای هر راس <span class="math">\(u\)</span> اگر تعدادی از کپی های <span class="math">\(u\)</span> در <span class="math">\(S\)</span> آمده باشد ولی همه آن ها نیامده باشند می توان همه را به مجموعه <span class="math">\(S\)</span> اضافه کرد در اینصورت <span class="math">\(T\)</span> تغییری نخواهد کرد و تنها <span class="math">\(S\)</span> زیاد می شود. پس می توان فقط <span class="math">\(S\)</span> هایی را چک کرد که به ازای هر <span class="math">\(u\)</span> یا تمام کپی های <span class="math">\(u\)</span> آمده اند یا هیچکدام نیامده اند.</p>
<p>با کمی تفکر نتیجه می گیریم که طبق حرف های بالا می توان روی گراف <span class="math">\(G\)</span> این شرط لازم و کافی را پیدا کرد : <span class="math">\(\forall_{S} \sum\limits_{i \in S} a_i \leq |T|\)</span></p>
<p>که <span class="math">\(S\)</span> هر زیرمجموعه ای از راس های بخش اول گراف است و  <span class="math">\(T\)</span> اجتماع همسایه های <span class="math">\(S\)</span> است.</p>
</div>
</div>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="1.html" style="float:right;" title="آشنایی" accesskey="p"><i class="fa fa-chevron-right"></i>&nbsp; قبلی</a>
                    
                    
                    <a href="3.html" style="float:left;" title="قضایا ی مینماکس" accesskey="n">بعدی &nbsp;<i class="fa fa-chevron-left"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/"><img src="/_static/shaazzz_logo.png"></a>
            </div>
            <div id="text">
                <p>
                    این کتاب توسط 
                    <a href="/contributors">
                    مشارکت کنندگان شاززز
                    </a>
                    به وجود آمده است.
                </p>
                <p>
                    این کتاب عمومی است و تحت پروانه cc-by-sa در دسترس است.
                </p>
                    <p style="font-size: 13px;">
                        آخرین به روز رسانی در سپتامبر 12, 2020.
                    </p>
                <p style="font-size: 13px;">
                    
                        ساخته شده به وسیله <a href="http://sphinx-doc.org/">Sphinx</a> (1.6.7) و <a href="https://github.com/saeiddrv/SphinxMinooTheme">تم مینو</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img src="/_static/cc-by-sa.svg">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>